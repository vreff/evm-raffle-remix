// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.9;

import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";
import "../Raffle.sol";


/**
 * WORKSHOP STEPS FOR VRF EXTENSION:
 * 
 * 1. Go to https://vrf.chain.link/. Create and fund a subscription on Ethereum Goerli.
 * 
 * 2. Find the coordinator address and key hash for your consumer contract at https://docs.chain.link/docs/vrf-contracts/.
 * 
 * 3. Define the _subscriptionId and _keyHash variables with the info from steps 1 & 2.
 * 
 * 4. Implement the _randomPickWinner and fulfillRandomWords functions.
 * 
 * 5. Compile and deploy the VRFRaffle.sol contract with the Ethereum Goerli VRFv2 Coordinator address.
 * 
 * 6. Add the deployed contract address from step 5 as a consumer of the VRF subscription you created.
 * 
 * 7. Play the raffle!
 */


/** 
 * @title RaffleVRFRandomPick
 * @dev Extends the base raffle system with public functions plus VRF based winner selection
 */
abstract contract RaffleVRFRandomPick is Raffle, VRFConsumerBaseV2 {
    
    uint64 private constant _subscriptionId; // Subscription ID of the VRF consumer

    bytes32 private constant _keyHash; // The key hash to be used for the VRF request

    uint32 private constant _numWords =  1; // Number of random words the consumer will request
    
    uint16 private constant _requestConfirmations = 3; // The delay in blocks before the VRF request is served

    uint32 private constant _callbackGasLimit = 100000; // The gas limit given to 

    uint256 public requestId; // The request ID of the VRF request once it is made

    VRFCoordinatorV2Interface COORDINATOR; // The VRF Coordinator


    /**
     * @param vrfCoordinatorAddress the address of the VRFv2 Coordinator.
     */
    constructor(
        address vrfCoordinatorAddress
    ) VRFConsumerBaseV2(vrfCoordinatorAddress) {
        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinatorAddress);
    }

    /**
     * @notice Requests the random winner to be generated by calling the VRFCoordinator's requestRandomWords function.
     *
     * @dev hint: see the requestRandomWords function in VRFCoordinatorV2Interface.
     */
    function _randomPickWinner() internal virtual {
        // Implement me.
        requestId = COORDINATOR.requestRandomWords(
            _keyHash,
            _subscriptionId,
            _requestConfirmations,
            _callbackGasLimit,
            _numWords
        );
    }

    /**
     * @notice Fulfilled by VRF node. Parses the winner's index of the entry array[] by taking the modulo
     * of the first element of the randomWords array by the number of entrants, 
     * and passes that index to the _resolveRandomPick function.
     * 
     * @param randomWords a list of random words i.e [uint256 rand1, uint256 rand2, ...]
     *
     * @dev hint: use the modulo of getEntryCount() from Raffle.sol on the first item in the randomWords array, 
     * then use the _resolveRandomPick function 
     */
    function fulfillRandomWords(
        uint256, /* requestId */
        uint256[] memory randomWords
    ) internal override {
        uint256 idx = randomWords[0]%getEntryCount();
        _resolveRandomPick(idx);
    }

    function _resolveRandomPick(uint256 idx) internal virtual {
        _pickWinner(idx);
    }
}


interface VRFCoordinatorV2Interface {

  /**
   * @notice Request a set of random words.
   * @param keyHash - Corresponds to a particular oracle job which uses
   * that key for generating the VRF proof. Different keyHash's have different gas price
   * ceilings, so you can select a specific one to bound your maximum per request cost.
   * @param subId  - The ID of the VRF subscription. Must be funded
   * with the minimum subscription balance required for the selected keyHash.
   * @param minimumRequestConfirmations - How many blocks you'd like the
   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS
   * for why you may want to request more. The acceptable range is
   * [minimumRequestBlockConfirmations, 200].
   * @param callbackGasLimit - How much gas you'd like to receive in your
   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords
   * may be slightly less than this amount because of gas used calling the function
   * (argument decoding etc.), so you may need to request slightly more than you expect
   * to have inside fulfillRandomWords. The acceptable range is
   * [0, maxGasLimit]
   * @param numWords - The number of uint256 random values you'd like to receive
   * in your fulfillRandomWords callback. Note these numbers are expanded in a
   * secure way by the VRFCoordinator from a single random value supplied by the oracle.
   * @return requestId - A unique identifier of the request. Can be used to match
   * a request to a response in fulfillRandomWords.
   */
  function requestRandomWords(
    bytes32 keyHash,
    uint64 subId,
    uint16 minimumRequestConfirmations,
    uint32 callbackGasLimit,
    uint32 numWords
  ) external returns (uint256 requestId);
}
